<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Gossip protocol</title>
    <link href="/2023/07/22/Gossip-protocol/"/>
    <url>/2023/07/22/Gossip-protocol/</url>
    
    <content type="html"><![CDATA[<p>Gossip 协议是一种分布式系统中的通信协议，用于在节点之间传播信息。它是一种去中心化的通信方式，节点通过相互之间的随机通信来传播信息，从而实现数据的分发和状态的同步。Gossip 协议通常用于构建大规模的分布式系统，例如分布式数据库、分布式存储系统、对等网络等。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/gif/365147/1670396390434-644e27f6-88d0-48e7-94a8-a71db896bb85.gif" alt="Gossip 图标"></p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>Gossip 协议的工作原理基于以下几个核心概念：</p><ol><li><p><strong>节点选择</strong>：<br>在 Gossip 协议中，每个节点都会随机地选择一些其他节点来进行通信。通常情况下，节点会选择一部分邻居节点来进行通信，也可以选择随机的节点。通过随机选择节点，Gossip 协议能够实现信息的广播和分发，确保信息能够迅速地在整个系统中传播。</p></li><li><p><strong>信息交换</strong>：<br>当两个节点进行通信时，它们会交换信息，其中包括节点本身的状态信息、数据更新、事件通知等。通过信息交换，节点能够了解其他节点的状态，并进行相应的调整和更新。</p></li><li><p><strong>传播和接受</strong>：<br>节点在与其他节点通信后，会将接收到的信息再次传播给其他节点，从而实现信息的广播和传播。通过不断地传播和接收信息，节点之间逐渐达成共识，保持状态的一致性。</p></li></ol><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>Gossip 协议具有以下特点：</p><ol><li><p><strong>去中心化</strong>：<br>Gossip 协议是一种去中心化的通信方式，节点之间平等地进行通信，没有中心节点的概念。每个节点都能够主动地选择和交互其他节点，实现信息的自由传播。</p></li><li><p><strong>高度容错</strong>：<br>Gossip 协议对节点的故障和网络分区具有很好的容错性能。即使部分节点宕机或者网络发生分区，其他节点仍然能够通过传播和接受信息来保持一致性。</p></li><li><p><strong>自适应性</strong>：<br>Gossip 协议能够根据节点的变化和网络环境的变化来自适应调整通信策略。节点选择和信息传播的策略可以根据实际情况动态调整，以适应系统的变化。</p></li><li><p><strong>高效性</strong>：<br>Gossip 协议通过随机选择节点来进行通信，避免了集中式通信和节点的全局状态信息交换，使得通信开销相对较小，能够适应大规模分布式系统。</p></li></ol><p>总的来说，Gossip 协议是一种高效、去中心化和具有高度容错性的分布式通信协议，它在大规模分布式系统中有着广泛的应用。通过随机选择节点进行通信和信息传播，Gossip 协议能够实现节点之间的数据同步和状态一致性，保持系统的可靠性和稳定性。</p>]]></content>
    
    
    <categories>
      
      <category>protocol</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Gossip</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ConcurrentHashMap</title>
    <link href="/2023/07/22/ConcurrentHashMap/"/>
    <url>/2023/07/22/ConcurrentHashMap/</url>
    
    <content type="html"><![CDATA[<h3 id="Java集合-ConcurrentHashMap"><a href="#Java集合-ConcurrentHashMap" class="headerlink" title="Java集合 ConcurrentHashMap"></a>Java集合 <code>ConcurrentHashMap</code></h3><p><code>ConcurrentHashMap</code> 是 Java 并发包中的一个线程安全的哈希表实现，它扩展了 <code>HashMap</code> 并支持高并发环境下的并发操作。<code>ConcurrentHashMap</code> 允许多个线程同时读取和写入数据，而不需要显式地加锁。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li><p><strong>分段锁</strong>：<br>在 JDK 1.7 版本及之前，<code>ConcurrentHashMap</code> 使用了分段锁（Segment）的机制，将哈希表分成多个小的段（Segment），每个段都拥有一个独立的锁。不同的线程可以同时对不同的段进行并发操作，从而提高并发性能。但是在 JDK 1.8 版本之后，已经废弃了分段锁，采用了更加高效的 CAS（Compare and Swap）和 synchronized 实现。</p></li><li><p><strong>并发度</strong>：<br><code>ConcurrentHashMap</code> 的并发度是指内部分段的个数。在 JDK 1.7 及之前，默认的并发度是 16，可以在构造函数中指定并发度。在 JDK 1.8 及之后，<code>ConcurrentHashMap</code> 不再提供构造函数指定并发度，而是采用了自动根据 CPU 核心数来设定并发度，通常是 CPU 核心数的 2 倍。</p></li><li><p><strong>无需加锁的读操作</strong>：<br><code>ConcurrentHashMap</code> 的读操作不需要加锁，多个线程可以同时进行读取，提高了并发读的效率。</p></li><li><p><strong>适用场景</strong>：<br><code>ConcurrentHashMap</code> 适用于多线程同时读写的场景，它可以在保持高并发性能的同时，提供线程安全的数据访问。</p></li></ol><p>总的来说，<code>ConcurrentHashMap</code> 是一个线程安全的哈希表实现，它在高并发环境下表现出色，并且在 JDK 1.8 及之后的版本中进行了优化，不再使用分段锁，而是采用了更加高效的并发控制机制，使其在各种场景下都能保持较好的性能表现。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ConcurrentHashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java keyword volatile</title>
    <link href="/2023/07/22/Java-keyword-volatile/"/>
    <url>/2023/07/22/Java-keyword-volatile/</url>
    
    <content type="html"><![CDATA[<h3 id="Java关键字volatile"><a href="#Java关键字volatile" class="headerlink" title="Java关键字volatile"></a>Java关键字<code>volatile</code></h3><p><code>volatile</code> 是 Java 中用来修饰变量的关键字，它的主要作用是告诉编译器和CPU，这个变量可能会被多个线程同时访问，需要确保线程之间的可见性和顺序性。当一个变量被声明为 <code>volatile</code>，在修改该变量的值时，会立即刷新到主内存中，同时在读取该变量时，会从主内存中获取最新的值，而不是使用线程的本地缓存。</p><h3 id="问题：可见性和原子性"><a href="#问题：可见性和原子性" class="headerlink" title="问题：可见性和原子性"></a>问题：可见性和原子性</h3><p>Java 中的多线程编程涉及到多个线程访问共享数据的情况。在没有同步机制保护的情况下，线程之间可能会产生数据不一致的问题。而 <code>volatile</code> 的作用正是为了解决可见性问题，它能够保证当一个线程修改了 <code>volatile</code> 变量的值时，其他线程能够立即看到这个修改。这样，就避免了多个线程对同一个变量进行操作时，读取到的是过期数据的问题。</p><p>然而，<code>volatile</code> 并不能解决原子性问题。原子性是指一个操作是不可分割的，要么全部执行成功，要么全部失败。在 <code>volatile</code> 变量上进行复合操作（比如自增）时，并不能保证原子性。多个线程同时对同一个 <code>volatile</code> 变量进行复合操作，可能会导致结果出现错误。</p><h3 id="原因：线程的本地缓存和指令重排"><a href="#原因：线程的本地缓存和指令重排" class="headerlink" title="原因：线程的本地缓存和指令重排"></a>原因：线程的本地缓存和指令重排</h3><p>Java 中的线程在执行时，为了提高执行效率，会将变量存储在线程的本地缓存中。这就导致了一个问题：一个线程修改了一个共享变量的值，但由于其他线程使用的是本地缓存，它们可能无法立即看到修改后的值，而是使用了过期的值。</p><p>此外，为了提高程序的执行效率，JVM 和CPU 可能会对指令进行重排。在不改变单线程执行结果的前提下，JVM 和 CPU 可能会对指令的执行顺序进行优化。而这种指令重排在多线程环境下可能会导致线程读取到不正确的数据。</p><p>因此，Java 使用 <code>volatile</code> 关键字来告诉编译器和 CPU，这个变量可能会被多个线程同时访问，需要避免指令重排，并在修改变量时立即刷新到主内存，以保证线程之间的可见性和顺序性。但需要注意的是，<code>volatile</code> 并不能保证复合操作的原子性，需要结合其他同步机制来解决原子性问题。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>volatile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis Cluster detail</title>
    <link href="/2023/07/22/Redis-Cluster-detail/"/>
    <url>/2023/07/22/Redis-Cluster-detail/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h2><p>Redis Cluster 是 Redis 分布式集群的一种实现方式，它能够在多个节点上分布和存储数据，并提供高可用性和扩展性。Redis Cluster 通过分片和数据复制来实现数据的分布和容错，确保即使在部分节点失效的情况下，整个集群仍然能够正常工作。</p><h3 id="主要特性："><a href="#主要特性：" class="headerlink" title="主要特性："></a>主要特性：</h3><ol><li><p><strong>数据分片（Sharding）</strong>：<br>Redis Cluster 将数据分成多个分片，每个分片分布在不同的节点上。这样可以有效地将数据分散到不同的服务器上，提高读写性能。</p></li><li><p><strong>高可用性</strong>：<br>Redis Cluster 使用主从复制的方式来保证数据的高可用性。每个分片都有主节点和若干个从节点，当主节点故障时，从节点会自动接替主节点的功能，确保数据的持久性和可用性。</p></li><li><p><strong>故障转移</strong>：<br>当主节点不可用时，Redis Cluster 使用自动故障转移来选择从节点中的一个作为新的主节点，确保集群在故障时能够自动恢复。</p></li><li><p><strong>动态扩展</strong>：<br>Redis Cluster 允许在运行时动态地增加或减少节点，以适应数据规模的变化。这使得集群的扩展非常容易和灵活。</p></li><li><p><strong>内置的客户端分片</strong>：<br>Redis Cluster 的客户端可以通过哈希槽来将数据分布到正确的分片上，不需要应用程序自己处理数据分片的逻辑。</p></li></ol><h3 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h3><p>配置 Redis Cluster 需要在启动 Redis 时指定不同节点的 IP 和端口，并在配置文件中设置集群模式。各个节点会自动发现彼此并建立通信。</p><h3 id="Redis-Cluster-运作原理："><a href="#Redis-Cluster-运作原理：" class="headerlink" title="Redis Cluster 运作原理："></a>Redis Cluster 运作原理：</h3><p>Redis Cluster 使用哈希槽（Hash Slot）来分布数据。整个数据空间被分成固定数量的哈希槽（默认为 16384 个），每个节点负责其中一部分哈希槽的数据。客户端将数据的键进行哈希运算，得到一个哈希槽号，然后根据哈希槽号与节点的对应关系，将数据发送到相应的节点。</p><p>通过哈希槽的分布和节点的复制，Redis Cluster 实现了数据的高可用性和分布式存储。当集群中的某个节点出现故障时，集群会自动进行故障转移，将失效节点的哈希槽重新分配到其他节点上，从而保持数据的完整性和可用性。</p><p>总的来说，Redis Cluster 提供了一个稳定、高可用和可扩展的分布式 Redis 解决方案，适用于大规模的数据存储和处理场景。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis cluster</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis Cluster solution</title>
    <link href="/2023/07/22/Redis-Cluster-solution/"/>
    <url>/2023/07/22/Redis-Cluster-solution/</url>
    
    <content type="html"><![CDATA[<p>下面是 Redis 集群方案的几种常见方式：</p><h3 id="Redis-Sentinel-高可用方案"><a href="#Redis-Sentinel-高可用方案" class="headerlink" title="Redis Sentinel 高可用方案"></a>Redis Sentinel 高可用方案</h3><p>Redis Sentinel 是官方推荐的 Redis 高可用方案，它使用 Sentinel 进程来监控 Redis 主从节点的状态，并在主节点宕机时自动进行故障转移。这种方案适用于小规模的高可用需求，适合用于监控少量 Redis 实例。</p><h3 id="Redis-Cluster-集群方案"><a href="#Redis-Cluster-集群方案" class="headerlink" title="Redis Cluster 集群方案"></a>Redis Cluster 集群方案</h3><p>Redis Cluster 是 Redis 官方提供的分布式解决方案，它通过一致性哈希算法将数据分片存储在多个节点上，实现数据的分布式存储和横向扩展。Redis Cluster 方案适用于大规模的高可用和高性能需求，适合用于监控大量 Redis 实例。</p><h3 id="Twemproxy-nutcracker-方案"><a href="#Twemproxy-nutcracker-方案" class="headerlink" title="Twemproxy (nutcracker) 方案"></a>Twemproxy (nutcracker) 方案</h3><p>Twemproxy，也称为 nutcracker，是 Twitter 开源的 Redis 代理服务器，用于实现 Redis 的分片和高可用。它可以将多个 Redis 实例组合成一个逻辑的 Redis 服务，并提供客户端路由和故障转移等功能。Twemproxy 方案适用于中等规模的高可用需求，适合用于监控中等数量的 Redis 实例。</p><h3 id="Codis-方案"><a href="#Codis-方案" class="headerlink" title="Codis 方案"></a>Codis 方案</h3><p>Codis 是另一个开源的 Redis 集群方案，它在 Redis 原生协议之上实现了代理层，提供了分片和高可用的功能。Codis 方案适用于中等规模的高可用和高性能需求，适合用于监控中等数量的 Redis 实例。</p><p>这些 Redis 集群方案各有优劣，选择合适的方案取决于具体的业务需求和系统规模。在选择和部署 Redis 集群方案时，需要综合考虑系统的性能、可靠性、复杂性和成本等因素。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cluster</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo Knowledge points</title>
    <link href="/2023/07/22/Dubbo-Knowledge-points/"/>
    <url>/2023/07/22/Dubbo-Knowledge-points/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Dubbo知识点整理</p><h2 id="Dubbo-知识点"><a href="#Dubbo-知识点" class="headerlink" title="Dubbo 知识点"></a>Dubbo 知识点</h2><p>Dubbo是一款高性能的分布式服务框架，由阿里巴巴开源，用于解决分布式系统中的服务治理问题。下面是Dubbo的一些重要知识点：</p><h3 id="1-Dubbo-简介"><a href="#1-Dubbo-简介" class="headerlink" title="1. Dubbo 简介"></a>1. Dubbo 简介</h3><p>Dubbo是一款开源的高性能、轻量级的分布式服务框架，它提供了服务注册、发现、远程调用、负载均衡等分布式服务治理功能，使得分布式系统开发更加简单和高效。</p><h3 id="2-Dubbo-核心概念"><a href="#2-Dubbo-核心概念" class="headerlink" title="2. Dubbo 核心概念"></a>2. Dubbo 核心概念</h3><ul><li>服务提供者(Provider)：暴露服务的服务提供方。</li><li>服务消费者(Consumer)：调用远程服务的服务消费方。</li><li>注册中心(Registry)：用于服务的注册与发现，Dubbo支持多种注册中心，如ZooKeeper、Consul等。</li><li>监控中心(Monitor)：用于统计服务的调用次数和调用时间等。</li><li>服务容器(Container)：服务运行容器，负责启动、加载、运行服务提供者。</li></ul><h3 id="3-Dubbo-服务暴露与引用"><a href="#3-Dubbo-服务暴露与引用" class="headerlink" title="3. Dubbo 服务暴露与引用"></a>3. Dubbo 服务暴露与引用</h3><ul><li>服务暴露：通过<code>@Service</code>注解将服务接口实现类暴露为Dubbo服务，并配置服务的协议、注册中心等信息。</li><li>服务引用：通过<code>@Reference</code>注解或配置XML来引用远程服务，获取对服务接口的代理对象，从而进行远程调用。</li></ul><h3 id="4-Dubbo-配置"><a href="#4-Dubbo-配置" class="headerlink" title="4. Dubbo 配置"></a>4. Dubbo 配置</h3><p>Dubbo提供了丰富的配置选项，可以通过XML配置文件或注解进行配置，包括服务提供者和服务消费者的配置，以及注册中心、协议、负载均衡等配置。</p><h3 id="5-Dubbo-负载均衡"><a href="#5-Dubbo-负载均衡" class="headerlink" title="5. Dubbo 负载均衡"></a>5. Dubbo 负载均衡</h3><p>Dubbo支持多种负载均衡策略，用于决定服务消费者选择哪个服务提供者进行远程调用。常见的负载均衡策略有：随机(Random)、轮询(RoundRobin)、最少活跃调用数(LeastActive)等。</p><h3 id="6-Dubbo-集群容错"><a href="#6-Dubbo-集群容错" class="headerlink" title="6. Dubbo 集群容错"></a>6. Dubbo 集群容错</h3><p>Dubbo提供了集群容错机制，用于处理服务调用时可能出现的失败情况，如服务提供者不可用、调用超时等。常见的集群容错策略有：失败自动切换(Failover)、失败快速失败(Failfast)、失败安全(Failsafe)等。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs tap">失败自动切换（Failover）：<br>失败自动切换是 Dubbo 默认的集群容错策略。当服务消费者在调用过程中遇到失败，比如请求超时或服务提供者抛出异常时，Dubbo 会自动切换到另一个可用的服务提供者进行重试。Dubbo 默认设置了重试次数为<span class="hljs-number"> 2 </span>次，可以通过配置进行调整。<br><br>失败快速失败（Failfast）：<br>失败快速失败策略是指在服务调用失败后立即返回失败的响应，不进行重试。这种策略适用于非幂等操作，比如写操作，因为重试可能会导致数据重复提交。<br><br>失败安全（Failsafe）：<br>失败安全策略是指在服务调用失败时，直接忽略失败的调用，不进行重试，将失败视为一个普通的警告，继续执行后续逻辑。这种策略适用于日志记录等不影响主要业务的情况。<br><br>失败自动恢复（Failback）：<br>失败自动恢复策略是指在服务调用失败后，后台记录失败的请求，并定时重发这些失败的请求，直到成功。这种策略适用于可靠性要求较高的场景，比如消息通知。<br><br>失败失败重试一次（Failover + Failfast）：<br>这种策略结合了失败自动切换和失败快速失败两种策略。在首次调用失败时会立即返回失败响应，但会进行一次重试，尝试调用另一个可用的服务提供者。<br><br>这些集群容错策略使得 Dubbo 在面对不同的分布式调用异常情况时，能够根据实际场景进行合理的处理，提高了系统的可用性和稳定性。在使用 Dubbo 时，可以根据业务需求和系统特点选择合适的集群容错策略，并通过 Dubbo 的配置进行相应的调整。<br></code></pre></td></tr></table></figure><h3 id="7-Dubbo-过滤器"><a href="#7-Dubbo-过滤器" class="headerlink" title="7. Dubbo 过滤器"></a>7. Dubbo 过滤器</h3><p>Dubbo提供了过滤器机制，可以在服务提供者和服务消费者之间进行过滤器链的调用，用于实现日志记录、安全认证、参数验证等功能。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scss">Dubbo 过滤器分为两类：<br><br>服务端过滤器（Provider <span class="hljs-attribute">Filter</span>）：<br>服务端过滤器在服务提供者端执行，用于在服务被调用之前和之后对请求进行处理。服务端过滤器的执行顺序与它们在 Dubbo 配置文件中的顺序有关，先声明的过滤器先执行。<br><br>客户端过滤器（Consumer <span class="hljs-attribute">Filter</span>）：<br>客户端过滤器在服务消费者端执行，用于在服务调用之前和之后对请求进行处理。客户端过滤器的执行顺序同样与它们在 Dubbo 配置文件中的顺序有关，先声明的过滤器先执行。<br><br>Dubbo 提供了一些内置的过滤器，例如：<br><br>AccessLogFilter：记录请求访问日志，可以查看请求的详细信息，如调用方IP、接口、方法、参数等。<br>ActiveLimitFilter：限制并发调用数，防止过多的并发请求对服务提供者造成压力。<br>EchoFilter：回声测试过滤器，用于检测服务是否正常。<br>ExceptionFilter：捕获服务调用过程中的异常，可用于异常处理和记录。<br>开发者还可以根据自己的需求实现自定义的过滤器，并通过 Dubbo 配置文件将其加入过滤器链中。自定义过滤器需要实现 <span class="hljs-attribute">Filter</span> 接口，并重写其 <span class="hljs-built_in">invoke</span>(Invoker, Invocation) 方法，这样在服务调用的时候就会触发自定义过滤器的执行。<br></code></pre></td></tr></table></figure><h3 id="8-Dubbo-异步调用"><a href="#8-Dubbo-异步调用" class="headerlink" title="8. Dubbo 异步调用"></a>8. Dubbo 异步调用</h3><p>Dubbo支持异步调用方式，可以在服务消费者发起调用后继续执行其他逻辑，待服务提供者处理完毕后再获取结果。</p><h3 id="9-Dubbo-SPI"><a href="#9-Dubbo-SPI" class="headerlink" title="9. Dubbo SPI"></a>9. Dubbo SPI</h3><p>Dubbo使用SPI（Service Provider Interface）机制来加载扩展点实现，可以通过SPI扩展机制自定义一些组件的实现。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs">自定义集群容错策略：<br>可以根据实际业务场景和需求，实现自定义的集群容错策略。例如，你可能需要一个特定的容错策略来处理某些业务场景下的失败情况，或者根据自己的需求来定制重试次数和重试间隔等参数。<br><br>自定义负载均衡策略：<br>Dubbo 默认提供了一些常见的负载均衡策略，但在特定的业务场景下，可能需要更加个性化的负载均衡策略。通过自定义负载均衡策略，你可以根据实际需求来选择合适的服务提供者进行调用。<br><br>自定义注册中心：<br>如果 Dubbo 默认提供的注册中心不符合你的需求，你可以实现自定义的注册中心来适配你的特定场景。比如，你可能希望将 Dubbo 与自己的服务发现系统集成，就可以实现一个自定义的注册中心。<br><br>自定义远程通信协议：<br>Dubbo 支持多种远程通信协议，但在特定情况下，你可能需要一个全新的远程通信协议来满足特定的需求。通过自定义远程通信协议，你可以实现自己的通信协议实现，与 Dubbo 集成。<br><br>自定义序列化方式：<br>如果 Dubbo 默认提供的序列化方式不满足你的需求，你可以实现自定义的序列化方式。比如，你可能希望使用一种特定的序列化算法来优化性能，或者与其他系统进行数据交换，就可以实现一个自定义的序列化方式。<br><br>自定义拓展点加载器：<br>Dubbo 的拓展点加载器是用于加载各种扩展点实现的机制，如果你希望扩展 Dubbo 的功能，可以通过自定义拓展点加载器来加载自定义的扩展点实现。<br></code></pre></td></tr></table></figure><h3 id="10-Dubbo-序列化"><a href="#10-Dubbo-序列化" class="headerlink" title="10. Dubbo 序列化"></a>10. Dubbo 序列化</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Dubbo的序列化是指在服务提供者和服务消费者之间传输数据时，将Java对象转换成字节流，或将字节流还原成Java对象的过程。在分布式系统中，服务的提供者和消费者通常运行在不同的进程或服务器上，需要通过网络进行数据传输。Dubbo默认使用Hessian2作为序列化方式，但也支持其他的序列化方式，如<span class="hljs-type">JSON</span>和FST。<br><br>Hessian2序列化：<br>Hessian2是一种高效的二进制序列化协议，它将Java对象转换为紧凑的二进制格式，使得数据传输更加高效。Hessian2序列化具有较低的序列化和反序列化开销，适合在分布式系统中传输大量的数据。Dubbo默认使用Hessian2作为序列化方式，可以通过在Dubbo配置中指定hessian2来启用。<br><br><span class="hljs-type">JSON</span>序列化：<br><span class="hljs-type">JSON</span>是一种常用的文本格式数据交换协议，相对于Hessian2而言，<span class="hljs-type">JSON</span>序列化产生的数据较大，传输效率相对较低，但可读性较好，适用于一些对数据可读性要求较高的场景。在Dubbo中，你可以选择使用<span class="hljs-type">json</span>作为序列化方式，通过配置来实现。<br><br>FST序列化：<br>FST（Fast-Serialization）是一种高性能的Java对象序列化框架，它通过直接操作字节码，绕过了Java的标准序列化机制，从而达到了更高的序列化和反序列化性能。FST序列化在性能方面优于Hessian2和<span class="hljs-type">JSON</span>，但可能不如Hessian2那么通用。Dubbo支持FST作为序列化方式，可以通过配置来启用。<br><br>选择合适的序列化方式取决于具体的业务需求和场景。对于数据量较大且传输性能要求较高的场景，Hessian2是一个不错的选择；如果对数据可读性要求较高，<span class="hljs-type">JSON</span>可以作为一个备选；而对于追求更高性能的场景，FST可能是更好的选择。在Dubbo中，你可以根据业务需求和系统性能来灵活选择合适的序列化方式。<br></code></pre></td></tr></table></figure><p>以上是Dubbo的一些核心知识点，当准备面试Java时，对于Dubbo的了解将对面试中的分布式系统和服务治理相关问题有很大帮助。希望这些知识点对您的面试有所帮助。祝您面试成功！</p>]]></content>
    
    
    <categories>
      
      <category>Dubbo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dubbo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>use jad in Linux</title>
    <link href="/2023/02/27/how-to-use-jad/"/>
    <url>/2023/02/27/how-to-use-jad/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>修复工单，本地调试OK，初步排查是线上版本部署代码不是最新的，登录docker后，找到jar文件并解压得到class文件</p><h2 id="Show-Code"><a href="#Show-Code" class="headerlink" title="Show Code"></a>Show Code</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://www.benf.org/other/cfr/cfr-0.144.jar<br><br>java -jar cfr-0.144.jar your_class.class &gt; out.java<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>jad</tag>
      
      <tag>反编译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CompletableFuture &amp;&amp; ScheduledExecutorService handle timeout</title>
    <link href="/2022/08/07/CompletableFuture-timeout-code/"/>
    <url>/2022/08/07/CompletableFuture-timeout-code/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>需要实现一个接口返回多个接口方法的数据，通过请求参数反射调用接口方法，如果接口方法超时，则返回默认值。<br>使用completableFuture，可以实现异步超时， jdk9已经有原生的实现，但是在jdk8需要自己做类似下面的实现, 需要利用applyToEigther的特性。</p><h2 id="Show-Code"><a href="#Show-Code" class="headerlink" title="Show Code"></a>Show Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">scheduler</span> <span class="hljs-operator">=</span> ExecutorsManager.getInstance().getScheduledExecutorService();<br><br><span class="hljs-keyword">public</span> BatchResponeVo <span class="hljs-title function_">batch</span><span class="hljs-params">(BatchRequestDto batchRequestDto)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br><br>    List&lt;CompletableFuture&lt;BatchResponeVo&gt;&gt; futuresList = Lists.newLinkedList();<br><br>    batchRequestDto.forEach((k, v) -&gt; &#123;<br>        <span class="hljs-type">BatchUriParamDto</span> <span class="hljs-variable">req</span> <span class="hljs-operator">=</span> JsonUtil.parseJsonUseJackson(JsonUtil.toJsonUseJackson(v), BatchUriParamDto.class);<br>        Map&lt;?, ?&gt; param = Objects.requireNonNull(req).getParam();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> req.getUri();<br><br>        <span class="hljs-type">BatchServiceEnum</span> <span class="hljs-variable">serviceEnum</span> <span class="hljs-operator">=</span> BatchServiceEnum.getEnumByServiceAndMethod(uri);<br>        CompletableFuture&lt;BatchResponeVo&gt; query = CompletableFuture.supplyAsync(() -&gt; &#123;<br>            <span class="hljs-type">BatchResponeVo</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BatchResponeVo</span>();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (Objects.isNull(serviceEnum)) &#123;<br>                    result.put(k, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BatchDataVo</span>(<span class="hljs-string">&quot;SystemError&quot;</span>, <span class="hljs-string">&quot;not required service method&quot;</span>, <span class="hljs-literal">null</span>));<br>                    <span class="hljs-keyword">return</span> result;<br>                &#125;<br><br>                Class&lt;?&gt; serviceClass = Class.forName(serviceEnum.getService());<br>                Class&lt;?&gt; paramClass = Class.forName(serviceEnum.getParam());<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> serviceClass.getMethod(serviceEnum.getMethod(), paramClass);<br><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> JsonUtil.parseJsonUseJackson(JsonUtil.toJsonUseJackson(param), paramClass);<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> SpringUtil.getBean(serviceClass);<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">invoke</span> <span class="hljs-operator">=</span> method.invoke(bean, obj);<br>                result.put(k, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BatchDataVo</span>(<span class="hljs-string">&quot;ok&quot;</span>, <span class="hljs-literal">null</span>, invoke));<br>                <span class="hljs-keyword">return</span> result;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException | InvocationTargetException | NoSuchMethodException |<br>                     IllegalAccessException e) &#123;<br>                log.error(<span class="hljs-string">&quot;ObservabilityService batch method error msg:&#123;&#125;&quot;</span>, e.getMessage(), e);<br>                result.put(k, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BatchDataVo</span>(<span class="hljs-string">&quot;SystemError&quot;</span>, e.getCause().getMessage(), <span class="hljs-literal">null</span>));<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br>        &#125;, scheduler);<br><br>        <span class="hljs-keyword">final</span> CompletableFuture&lt;BatchResponeVo&gt; chains = within(query, Duration.ofSeconds(<span class="hljs-number">10</span>), k);<br>        futuresList.add(chains);<br>    &#125;);<br>    CompletableFuture&lt;Void&gt; allCompletableFuture = CompletableFuture.allOf(futuresList.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>[<span class="hljs-number">0</span>]));<br><br>    <span class="hljs-type">BatchResponeVo</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BatchResponeVo</span>();<br>    allCompletableFuture.thenApply(v -&gt; futuresList.stream().map(CompletableFuture::join).collect(Collectors.toList()))<br>            .get()<br>            .forEach(result::putAll);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">public</span> CompletableFuture&lt;BatchResponeVo&gt; <span class="hljs-title function_">failAfter</span><span class="hljs-params">(Duration duration, String key)</span>&#123;<br>    <span class="hljs-comment">/// need a schedular executor</span><br>    <span class="hljs-keyword">final</span> CompletableFuture&lt;BatchResponeVo&gt; timer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;&gt;();<br>    scheduler.schedule(()-&gt; timer.complete(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BatchResponeVo</span>() &#123;&#123;<br>        put(key, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BatchDataVo</span>(<span class="hljs-string">&quot;SystemError&quot;</span>, <span class="hljs-string">&quot;method excute timeout &quot;</span>+duration.get(SECONDS)+<span class="hljs-string">&quot;s&quot;</span>, <span class="hljs-literal">null</span>));<br>    &#125;&#125;),duration.toMillis(), TimeUnit.MILLISECONDS);<br>    <span class="hljs-keyword">return</span> timer;<br>&#125;<br><br><span class="hljs-keyword">public</span> CompletableFuture&lt;BatchResponeVo&gt; <span class="hljs-title function_">within</span><span class="hljs-params">(CompletableFuture&lt;BatchResponeVo&gt; taskFuture, Duration duration, String key)</span>&#123;<br>    CompletableFuture&lt;BatchResponeVo&gt; timeoutWatcher = failAfter(duration, key);<br>    <span class="hljs-keyword">return</span> taskFuture.applyToEither(timeoutWatcher, Function.identity());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1306581182447650">使用CompletableFuture</a></li><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264803678201760">反射调用方法</a></li><li><a href="https://developer.aliyun.com/article/200625">Java中使用CompletableFuture处理异步超时</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>反射</tag>
      
      <tag>多线程</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
